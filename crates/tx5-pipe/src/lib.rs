#![deny(missing_docs)]
#![deny(unsafe_code)]
#![deny(warnings)]
#![doc = tx5_core::__doc_header!()]
//! # tx5-pipe
//!
//! Holochain WebRTC p2p cli tool.

/// Current Tx5Pipe version.
pub const TX5_PIPE_VERSION: &str = env!("CARGO_PKG_VERSION");

const HELP_TEXT: &str = r#"
# -- Begin Tx5Pipe Usage Info -- #
# # Request Messages (received on stdin):
# 'sig_reg cmd_id |sig_url|'     - connect to a signal server
# 'send cmd_id rem_url |data|'   - send outgoing data to a peer
# # Response Messages (sent on stdout):
# '<help version |info|'         - this help info
# '<error cmd_id code |text|'    - error response to a request
# '<sig_reg_ok cmd_id |cli_url|' - okay response to a sig_reg
# '<send_ok cmd_id ||'           - okay response to a send
# '<recv rem_url |data|'         - receive incoming peer data
# -- End Tx5Pipe Usage Info -- #"#;

use std::sync::Arc;
use tx5_core::pipe_ipc::*;
use tx5_core::Tx5Url;

/// Implement this to handle events generated by Tx5Pipe.
pub trait Tx5PipeHandler: 'static + Send + Sync {
    /// A fatal error was generated, the pipe is closed.
    fn fatal(&self, error: std::io::Error);

    /// A pipe response was generated. This function should return:
    /// - `true` if we should keep running, or
    /// - `false` if we should shut down the pipe.
    fn pipe(&self, response: Tx5PipeResponse) -> bool;
}

type DynTx5PipeHandler = Arc<dyn Tx5PipeHandler + 'static + Send + Sync>;

/// The Tx5Pipe struct.
pub struct Tx5Pipe {
    ep: tx5::Ep,
    hnd: DynTx5PipeHandler,
}

impl Tx5Pipe {
    /// Construct a new Tx5Pipe instance.
    pub async fn new<H: Tx5PipeHandler>(hnd: H) -> std::io::Result<Self> {
        let (ep, mut recv) = tx5::Ep::new().await?;

        let hnd: DynTx5PipeHandler = Arc::new(hnd);

        if !hnd.pipe(Tx5PipeResponse::Tx5PipeHelp {
            version: TX5_PIPE_VERSION.to_string(),
            info: HELP_TEXT.to_string(),
        }) {
            return Err(tx5_core::Error::err(
                "instructed to shutdown by recv handler",
            ));
        }

        {
            let hnd = hnd.clone();
            tokio::task::spawn(async move {
                while let Some(evt) = recv.recv().await {
                    let evt = match evt {
                        Err(err) => {
                            hnd.fatal(err);
                            return;
                        }
                        Ok(evt) => evt,
                    };
                    if let tx5::EpEvt::Data {
                        rem_cli_url,
                        data,
                        permit: _permit,
                    } = evt
                    {
                        if !hnd.pipe(Tx5PipeResponse::Recv {
                            rem_url: rem_cli_url.to_string(),
                            data,
                        }) {
                            hnd.fatal(tx5_core::Error::err(
                                "instructed to shutdown by recv handler",
                            ));
                            return;
                        }
                    }
                }
            });
        }

        Ok(Self { ep, hnd })
    }

    /// Send a pipe request into the Tx5Pipe instance.
    pub fn pipe(&self, req: Tx5PipeRequest) {
        let ep = self.ep.clone();
        let hnd = self.hnd.clone();
        tokio::task::spawn(async move {
            match req {
                Tx5PipeRequest::SigReg { cmd_id, sig_url } => {
                    handle_resp(
                        hnd,
                        cmd_id.clone(),
                        sig_reg(ep, cmd_id, sig_url).await,
                    );
                }
                Tx5PipeRequest::Send {
                    cmd_id,
                    rem_url,
                    data,
                } => {
                    handle_resp(
                        hnd,
                        cmd_id.clone(),
                        send(ep, cmd_id, rem_url, data).await,
                    );
                }
            }
        });
    }
}

fn handle_resp(
    hnd: DynTx5PipeHandler,
    cmd_id: String,
    rsp: std::io::Result<Tx5PipeResponse>,
) {
    let rsp = match rsp {
        Ok(rsp) => rsp,
        Err(err) => Tx5PipeResponse::Error {
            cmd_id,
            code: 0,
            text: format!("{err:?}"),
        },
    };
    if !hnd.pipe(rsp) {
        todo!("handle pipe close in responder"); // TODO - FIXME
    }
}

async fn sig_reg(
    ep: tx5::Ep,
    cmd_id: String,
    sig_url: String,
) -> std::io::Result<Tx5PipeResponse> {
    let sig_url = Tx5Url::new(sig_url)?;
    let cli_url = ep.listen(sig_url).await?;
    Ok(Tx5PipeResponse::SigRegOk {
        cmd_id,
        cli_url: cli_url.to_string(),
    })
}

async fn send(
    ep: tx5::Ep,
    cmd_id: String,
    rem_url: String,
    data: Box<dyn bytes::Buf + Send>,
) -> std::io::Result<Tx5PipeResponse> {
    let rem_url = Tx5Url::new(rem_url)?;
    ep.send(rem_url, data).await?;
    Ok(Tx5PipeResponse::SendOk { cmd_id })
}
